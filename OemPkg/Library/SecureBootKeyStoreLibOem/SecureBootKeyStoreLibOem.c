/** @file PlatformKeyLib.c

  Copyright (C) Microsoft Corporation. All rights reserved.
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/

#include <Uefi.h>
#include <UefiSecureBoot.h>

#include <Pi/PiFirmwareFile.h>

#include <Guid/ImageAuthentication.h>

#include <Library/SecureBootVariableLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/DxeServicesLib.h>

#include "MsSecureBootDefaultVars.h"

#define PLATFORM_SECURE_BOOT_KEY_COUNT  2

SECURE_BOOT_PAYLOAD_INFO  *gSecureBootPayload     = NULL;
UINT8                     gSecureBootPayloadCount = 0;

// Note: This will not work as it will not be accepted as a valid X509 cert
CONST UINT8  mDevelopmentPlatformKeyCertificate[] = {
    0x30, 0x82, 0x02, 0xe3, 0x30, 0x82, 0x01, 0xcb, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x1b,  // 0...0...........
    0xc2, 0x2a, 0x8a, 0x90, 0x17, 0x48, 0xab, 0x45, 0x01, 0xef, 0x5b, 0x70, 0x62, 0xd6, 0xf3, 0x30,  // .*...H.E..[pb..0
    0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x14,  // ...*.H........0.
    0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x09, 0x54, 0x65, 0x73, 0x74, 0x4f,  // 1.0...U....TestO
    0x65, 0x6d, 0x50, 0x4b, 0x30, 0x1e, 0x17, 0x0d, 0x32, 0x33, 0x30, 0x37, 0x32, 0x35, 0x32, 0x33,  // emPK0...23072523
    0x30, 0x35, 0x34, 0x30, 0x5a, 0x17, 0x0d, 0x33, 0x33, 0x30, 0x37, 0x32, 0x35, 0x32, 0x33, 0x31,  // 0540Z..330725231
    0x35, 0x34, 0x30, 0x5a, 0x30, 0x14, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c,  // 540Z0.1.0...U...
    0x09, 0x54, 0x65, 0x73, 0x74, 0x4f, 0x65, 0x6d, 0x50, 0x4b, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d,  // .TestOemPK0.."0.
    0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01,  // ..*.H...........
    0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xc5, 0xaf, 0xd6, 0xcc, 0x29,  // ..0............)
    0x16, 0x28, 0xfc, 0x11, 0x25, 0x5a, 0x16, 0x92, 0xb8, 0x6c, 0x2a, 0x56, 0xba, 0x20, 0x2e, 0xaf,  // .(..%Z...l*V. ..
    0x70, 0x4f, 0x95, 0x81, 0x20, 0xcb, 0x37, 0x81, 0x19, 0x2a, 0xda, 0x70, 0x00, 0xfb, 0xf7, 0x02,  // pO.. .7..*.p....
    0x02, 0xd5, 0x9d, 0x52, 0xd5, 0xb6, 0xb1, 0x72, 0x87, 0x8f, 0xa7, 0x40, 0x30, 0x92, 0x75, 0x9d,  // ...R...r...@0.u.
    0xc4, 0xd7, 0x32, 0x6e, 0xe7, 0x11, 0xcc, 0xed, 0x26, 0x6b, 0x3d, 0xcb, 0x41, 0x1a, 0x22, 0x22,  // ..2n....&k=.A.""
    0x4b, 0x59, 0x99, 0xb9, 0xfb, 0xa8, 0x5b, 0xa5, 0x21, 0xc5, 0xea, 0x47, 0x01, 0xd1, 0x8f, 0x34,  // KY....[.!..G...4
    0x77, 0x27, 0xa5, 0x87, 0x85, 0x7b, 0x8d, 0xc2, 0xc2, 0x62, 0xe5, 0xc6, 0x26, 0x0a, 0x9b, 0x95,  // w'...{...b..&...
    0x18, 0x0c, 0x23, 0x53, 0x18, 0x12, 0x4c, 0xf0, 0xe2, 0xde, 0xdc, 0x61, 0x42, 0xb2, 0x12, 0x5c,  // ..#S..L....aB..
    0xf6, 0xc2, 0x6d, 0x4c, 0x90, 0x54, 0x74, 0x32, 0x11, 0xec, 0x29, 0x31, 0x99, 0x73, 0x67, 0x7b,  // ..mL.Tt2..)1.sg{
    0x16, 0xdb, 0xfc, 0x7d, 0xf0, 0x95, 0xa4, 0x04, 0x0f, 0xb7, 0x96, 0xff, 0x66, 0x94, 0x3e, 0xb9,  // ...}........f.>.
    0xb1, 0xfe, 0x41, 0x16, 0x87, 0x3b, 0x67, 0xef, 0xbb, 0x0c, 0x83, 0x76, 0xa0, 0xd4, 0x66, 0xa5,  // ..A..;g....v..f.
    0x17, 0xa6, 0xde, 0xa5, 0x67, 0x01, 0x24, 0x90, 0x11, 0x2e, 0x5f, 0xad, 0xaf, 0x98, 0x5c, 0xf6,  // ....g.$..._...\.
    0x98, 0xc9, 0x14, 0x8e, 0xdd, 0xcb, 0x3b, 0x6f, 0x22, 0x1b, 0x6e, 0xb1, 0x78, 0x8b, 0xbd, 0xae,  // ......;o".n.x...
    0x51, 0xe4, 0x92, 0xfb, 0xc5, 0xdc, 0xe7, 0x42, 0x32, 0x3f, 0xc9, 0x66, 0x36, 0x6e, 0xa8, 0xaf,  // Q......B2?.f6n..
    0x75, 0x23, 0x44, 0x15, 0x97, 0xaa, 0x9f, 0x6e, 0x4a, 0x9e, 0xf6, 0xeb, 0x2e, 0xd9, 0xa2, 0x8d,  // u#D....nJ.......
    0xcd, 0xfe, 0xf2, 0x36, 0x72, 0x1b, 0xfa, 0x10, 0xfd, 0xbc, 0xaf, 0x8c, 0x3c, 0x04, 0x6a, 0x89,  // ...6r.......<.j.
    0x7c, 0x17, 0xbe, 0x67, 0xbc, 0x86, 0x4d, 0x0f, 0x42, 0xf5, 0x5d, 0x02, 0x03, 0x01, 0x00, 0x01,  // |..g..M.B.].....
    0xa3, 0x31, 0x30, 0x2f, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04,  // .10/0...U.......
    0x03, 0x02, 0x07, 0x80, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x62,  // ....0...U......b
    0xa3, 0x60, 0x5e, 0xe1, 0xf7, 0xf3, 0x45, 0x5a, 0xed, 0x6e, 0x17, 0x8f, 0x9d, 0xe9, 0xe3, 0xad,  // .`^...EZ.n......
    0xaf, 0x4e, 0xcd, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b,  // .N.0...*.H......
    0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x47, 0x87, 0x38, 0xb0, 0xe4, 0x08, 0x33, 0xef, 0x01,  // .......G.8...3..
    0xb0, 0xfb, 0xcc, 0x66, 0x4f, 0xec, 0xc1, 0xbf, 0x66, 0x48, 0xcf, 0x41, 0x83, 0xd3, 0x6d, 0x28,  // ...fO...fH.A..m(
    0x6c, 0x1b, 0x8b, 0x70, 0x03, 0xbb, 0xf1, 0x52, 0x08, 0xd9, 0x52, 0x22, 0xd9, 0x99, 0x92, 0x69,  // l..p...R..R"...i
    0x10, 0xcf, 0x00, 0xdd, 0xaf, 0xe2, 0x6c, 0xd1, 0x36, 0x6e, 0x0f, 0xfd, 0xb2, 0x5b, 0xb2, 0xcf,  // ......l.6n...[..
    0x3d, 0x84, 0x53, 0x9a, 0xdb, 0xaf, 0xad, 0xe5, 0x7d, 0xfb, 0x64, 0xfe, 0xd9, 0x59, 0x2b, 0x5f,  // =.S.....}.d..Y+_
    0x00, 0xe6, 0x81, 0xc1, 0xb3, 0xae, 0xf1, 0xea, 0x26, 0x29, 0x29, 0x05, 0x7a, 0x6c, 0x18, 0xdf,  // ........&)).zl..
    0xf4, 0x54, 0x6c, 0xab, 0x91, 0x1c, 0x86, 0x11, 0x8d, 0x43, 0x49, 0xcc, 0xdc, 0x71, 0x76, 0xb8,  // .Tl......CI..qv.
    0x4c, 0x9b, 0xa0, 0xc6, 0x5e, 0x65, 0xcd, 0xa6, 0x46, 0x04, 0x31, 0x91, 0x83, 0xc2, 0x8d, 0x6d,  // L...^e..F.1....m
    0xe6, 0xf6, 0xb7, 0x92, 0x95, 0xa0, 0x72, 0xc6, 0x5d, 0x37, 0xf1, 0x6a, 0x62, 0x40, 0x5f, 0xad,  // ......r.]7.jb@_.
    0xd5, 0x40, 0xc7, 0x3b, 0x75, 0xa3, 0xad, 0xb5, 0xf9, 0xea, 0xb6, 0xc1, 0x07, 0xb2, 0x18, 0xff,  // .@.;u...........
    0xbe, 0x58, 0xf7, 0xdd, 0x68, 0x48, 0x35, 0x83, 0x64, 0x21, 0xc2, 0xce, 0x88, 0x40, 0x76, 0x5d,  // .X..hH5.d!...@v]
    0xd1, 0xe4, 0x1a, 0x52, 0xb9, 0x5c, 0xb0, 0xba, 0x67, 0x5f, 0x83, 0x51, 0x7c, 0xc3, 0x82, 0x00,  // ...R.\..g_.Q|...
    0xc6, 0xa3, 0x3a, 0x24, 0x54, 0x4c, 0xc4, 0xf9, 0xe8, 0xd7, 0x5d, 0x29, 0x36, 0xa1, 0xbc, 0xfb,  // ..:$TL....])6...
    0x2c, 0x25, 0x55, 0x16, 0x35, 0x50, 0x32, 0x60, 0x68, 0xe8, 0xb3, 0x5f, 0xe0, 0x5a, 0x0a, 0xe8,  // ,%U.5P2`h.._.Z..
    0xc5, 0x1b, 0x3b, 0xde, 0x6f, 0xc8, 0xa0, 0x41, 0x25, 0xf2, 0xb1, 0x94, 0x64, 0x2f, 0x55, 0x4a,  // ..;.o..A%...d/UJ
    0x81, 0xaf, 0x3c, 0x0b, 0xa5, 0x01, 0x9e, 0xe8, 0x27, 0xe5, 0x0b, 0xb2, 0xe9, 0x0e, 0xf2, 0xe8,  // ..<.....'.......
    0x33, 0xd3, 0x10, 0xf7, 0xd4, 0x49, 0x54                                                         // 3....IT
};

UINT8                     mSecureBootPayloadCount                            = PLATFORM_SECURE_BOOT_KEY_COUNT;
SECURE_BOOT_PAYLOAD_INFO  mSecureBootPayload[PLATFORM_SECURE_BOOT_KEY_COUNT] = {
  {
    .SecureBootKeyName = L"Microsoft Only",
    .KekPtr            = NULL,
    .KekSize           = 0,
    .DbPtr             = NULL,
    .DbSize            = 0,
    .DbxPtr            = NULL,
    .DbxSize           = 0,
    .DbtPtr            = NULL,
    .DbtSize           = 0,
  },
  {
    .SecureBootKeyName = L"Microsoft Plus 3rd Party",
    .KekPtr            = NULL,
    .KekSize           = 0,
    .DbPtr             = NULL,
    .DbSize            = 0,
    .DbxPtr            = NULL,
    .DbxSize           = 0,
    .DbtPtr            = NULL,
    .DbtSize           = 0,
  }
};

/**
  Interface to fetch platform Secure Boot Certificates, each payload
  corresponds to a designated set of db, dbx, dbt, KEK, PK.

  @param[in]  Keys        Pointer to hold the returned sets of keys. The
                          returned buffer will be treated as CONST and
                          permanent pointer. The consumer will NOT free
                          the buffer after use.
  @param[in]  KeyCount    The number of sets available in the returned Keys.

  @retval     EFI_SUCCESS             The Keys are properly fetched.
  @retval     EFI_INVALID_PARAMETER   Inputs have NULL pointers.
  @retval     Others                  Something went wrong. Investigate further.
**/
EFI_STATUS
EFIAPI
GetPlatformKeyStore (
  OUT SECURE_BOOT_PAYLOAD_INFO  **Keys,
  OUT UINT8                     *KeyCount
  )
{
  if ((Keys == NULL) || (KeyCount == NULL)) {
    return EFI_INVALID_PARAMETER;
  }

  *Keys     = gSecureBootPayload;
  *KeyCount = gSecureBootPayloadCount;

  return EFI_SUCCESS;
}

/**
  The constructor gets the secure boot platform keys populated.

  @retval EFI_SUCCESS     The constructor always returns EFI_SUCCESS.

**/
EFI_STATUS
EFIAPI
SecureBootKeyStoreLibConstructor (
  VOID
  )
{
  EFI_STATUS                    Status;
  UINTN                         DataSize;
  UINT8                         *KekDefault      = NULL;
  UINTN                         KekDefaultSize   = 0;
  UINT8                         *DbDefault       = NULL;
  UINTN                         DbDefaultSize    = 0;
  UINT8                         *Db3PDefault     = NULL;
  UINTN                         Db3PDefaultSize  = 0;
  UINT8                         *DbxDefault      = NULL;
  UINTN                         DbxDefaultSize   = 0;
  EFI_SIGNATURE_LIST            *SigListBuffer   = NULL;
  SECURE_BOOT_CERTIFICATE_INFO  TempInfo         = {
    .Data     = mDevelopmentPlatformKeyCertificate,
    .DataSize = sizeof (mDevelopmentPlatformKeyCertificate)
  };

  //
  // First, we must build the PK buffer with the correct data.
  //
  Status = SecureBootCreateDataFromInput (&DataSize, &SigListBuffer, 1, &TempInfo);

  if (EFI_ERROR (Status)) {
    DEBUG ((DEBUG_ERROR, "%a - Failed to build PK payload!\n", __FUNCTION__));
    ASSERT (FALSE);
  }

  Status = GetSectionFromAnyFv(
    PcdGetPtr(PcdSecureBootKekBinaryFile),
    EFI_SECTION_RAW,
    0,
    (VOID **)&KekDefault,
    &KekDefaultSize
  );
  if (EFI_ERROR (Status)) {
    DEBUG ((DEBUG_ERROR, "%a - Failed to Locate Kek Binary File in FV!\n", __FUNCTION__));
    ASSERT (FALSE);
  }
  DEBUG ((DEBUG_INFO, "DUMP_HEX"));
  DUMP_HEX(DEBUG_INFO, 0, KekDefault, KekDefaultSize, "");

  Status = GetSectionFromAnyFv(
    PcdGetPtr(PcdSecureBootDbBinaryFile),
    EFI_SECTION_RAW,
    0,
    (VOID **)&DbDefault,
    &DbDefaultSize
  );
  if (EFI_ERROR (Status)) {
    DEBUG ((DEBUG_ERROR, "%a - Failed to Locate Db Binary File in FV!\n", __FUNCTION__));
    ASSERT (FALSE);
  }

  Status = GetSectionFromAnyFv(
    PcdGetPtr(PcdSecureBoot3PDbBinaryFile),
    EFI_SECTION_RAW,
    0,
    (VOID **)&Db3PDefault,
    &Db3PDefaultSize
  );
  if (EFI_ERROR (Status)) {
    DEBUG ((DEBUG_ERROR, "%a - Failed to Locate 3P Db Binary File in FV!\n", __FUNCTION__));
    ASSERT (FALSE);
  }

  Status = GetSectionFromAnyFv(
    PcdGetPtr(PcdSecureBotDbxBinaryFile),
    EFI_SECTION_RAW,
    0,
    (VOID **)&DbxDefault,
    &DbxDefaultSize
  );
  if (EFI_ERROR (Status)) {
    DEBUG ((DEBUG_ERROR, "%a - Failed to Locate Dbx Binary File in FV!\n", __FUNCTION__));
    ASSERT (FALSE);
  }

  mSecureBootPayload[0].KekPtr = KekDefault;
  mSecureBootPayload[0].KekSize = KekDefaultSize;
  mSecureBootPayload[0].DbPtr = DbDefault;
  mSecureBootPayload[0].DbSize = DbDefaultSize;
  mSecureBootPayload[0].DbxPtr = DbxDefault;
  mSecureBootPayload[0].DbxSize = DbxDefaultSize;
  mSecureBootPayload[0].PkPtr = SigListBuffer;
  mSecureBootPayload[0].PkSize = DataSize;

  mSecureBootPayload[1].KekPtr = KekDefault;
  mSecureBootPayload[1].KekSize = KekDefaultSize;
  mSecureBootPayload[1].DbPtr = Db3PDefault;
  mSecureBootPayload[1].DbSize = Db3PDefaultSize;
  mSecureBootPayload[1].DbxPtr = DbxDefault;
  mSecureBootPayload[1].DbxSize = DbxDefaultSize;
  mSecureBootPayload[1].PkPtr = SigListBuffer;
  mSecureBootPayload[1].PkSize = DataSize;

  gSecureBootPayload      = mSecureBootPayload;
  gSecureBootPayloadCount = mSecureBootPayloadCount;

  return EFI_SUCCESS;
}

/**
  Destructor of SecureBootKeyStoreLib, to free any allocated resources.

  @retval EFI_SUCCESS   The destructor completed successfully.
  @retval Other value   The destructor did not complete successfully.

**/
EFI_STATUS
EFIAPI
SecureBootKeyStoreLibDestructor (
  VOID
  )
{
  VOID  *Buffer;

  // This should be initialized from constructor, so casting here is fine
  Buffer = (VOID *)mSecureBootPayload[0].PkPtr;
  if (Buffer != NULL) {
    FreePool (Buffer);
  }

  // Free the Kek allocated by GetSectionFromAnyFv
  Buffer = (VOID *)mSecureBootPayload[0].KekPtr;
  if (Buffer != NULL) {
    FreePool (Buffer);
  }

  // Free the Db allocated by GetSectionFromAnyFv
  Buffer = (VOID *)mSecureBootPayload[0].DbPtr;
  if (Buffer != NULL) {
    FreePool (Buffer);
  }

  // Free the 3P Db allocated by GetSectionFromAnyFv
  Buffer = (VOID *)mSecureBootPayload[1].DbPtr;
  if (Buffer != NULL) {
    FreePool (Buffer);
  }

  // Free the Dbx allocated by GetSectionFromAnyFv
  Buffer = (VOID *)mSecureBootPayload[0].DbxPtr;
  if (Buffer != NULL) {
    FreePool (Buffer);
  }

  return EFI_SUCCESS;
}
